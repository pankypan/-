创建numpy的坑, 会自动的进行类型转化str> float>int

numpy routines函数
np.zeros
np.ones
np.full
np.eye
np.arange
np.linspace
np.random.randn
np.random.randint
np.random.rand
np.random.normal
np.random.random

numpy的属性
ndim, shape, size, dtype

numpy的索引和切片
[,,]逗号是维度的分割
[::-1]反转

numpy, 变形
reshape, 要求size不变.


级联
concatenate(axis=0/1)
np.hstack()
np.vstack()

切分
np.split(axis=0/1)
np.vsplit()
np.hsplit()

副本
copy 深拷贝


聚合
sum, max, min, std, var, median,...
argmax, argmin, np.nansum, np.nanmax, np.nanmin
any, all


ndarray运算
广播,1,  缺失维度补维度.
     2, 缺失数据,用已有的数据补充.
	 
numpy排序  ndarray.sort() 不产生新内存, np.sort()有返回值.不修改原始数据.
部分排序, np.partition(kth=) 

# 第二天
Series

显式索引 .[], .loc[]推荐
隐式索引  .iloc[]

运算,相同的索引运算,不同的索引补nan, pandas定义好的运算函数,add, sub, div, mul

属性: shape, index, values, size, dtypes

DataFrame
多层索引(hierarchical indexing)
隐式: 直接传多维列表
显式: from_arrays, from_tuples, from_product

不能直接索引内层索引.

级联,合并
pd.concat((), join='outer', axis=0/1, keys=[], ignore_index=True/False, join_axes=[df1.index])
dataframe.append()

merge
pd.merge(left, right, how='inner', on='name', left_on=, right_on, left_index, right_index, suffixes=[])
df.merge()

isnull, notnull
df.isnull().any(axis=0/1) 每一列有没有空数据.

df.dropna(how='any'/all, inplace=True/False)

df.fillna(value='', method='bfill, backfill, pad, ffill', axis=0/1, limit=, inplace=True/False)


df.sum(axis=1, level=0) 

删除重复元素
duplicated()
drop_duplicates()

np.logical.not/ and/or/xor
~

映射
replace
map
rename

take
np.random.permutation()排列组合

df.stack()
df.unstack()


异常值的检测和过滤.
df[~(df.abs() > 3* df.std()).any(axis=1)]


高级聚合
1, groupby分组
2, 在分组的基础之上进行聚合df.groupby(by='color').sum()[['weight']], 
3, 使用merge,把聚合的结果合并原始数据中.
   df.merge(price_mean, left_on='item', right_index=True, suffixes=[])
   
数据加载
pd.read_csv(sep=',', header=None) seperator
pd.read_excel(sheet_name=)
pd.read_sql(sql, conn)

df.to_json /html/csv
df.to_sql(table_name, conn)
mysql sqlalchemy create_engine, 
df.to_sql(table_name, engine)



